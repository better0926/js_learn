<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>笔记</title>
  <!-- <link rel="stylesheet" href="lib/css/monokai-sublime.css"> -->
  <link rel="stylesheet" href="lib/css/default.min.css">
  <link rel="stylesheet" href="lib/css/vs2015.css">
  <link rel="stylesheet" href="lib/css/zTreeStyle/zTreeStyle.css">
  <link rel="stylesheet" href="lib/css/base.css">
  <link rel="stylesheet" href="lib/css/index.css">
</head>

<body>
  <div style='width:25%;'>
    <ul id="tree" class="ztree" style='width:100%'>

    </ul>
  </div>
  <div id='readme' style='width:70%;margin-left:20%;'>
    <article class='markdown-body'><h1 id="-">函数</h1>
<h2 id="-">为什么要有函数</h2>
<blockquote>
<p>在写代码的时候，有一些常用的代码需要书写多次，如果直接复制粘贴的话，会造成大量的冗余代码。</p>
<p>函数可以封装一段重复的JavaScript代码，它只需要声明一次，就可以被多次调用。</p>
</blockquote>
<p>重复代码、冗余代码的缺点：</p>
<ol>
<li><p>代码重复，可阅读性差</p>
</li>
<li><p>不易维护，如果代码逻辑改变了，所有地方的代码都要跟着改变，效率太低。</p>
</li>
</ol>
<h2 id="-">函数的声明与调用</h2>
<p>声明函数的语法：</p>
<pre><code class="lang-javascript">function 函数名(){
    //函数体
}
</code></pre>
<p>调用函数的语法：</p>
<pre><code class="lang-javascript">函数名();
</code></pre>
<p>特点：</p>
<pre><code class="lang-javascript">1. 函数声明的时候，函数体并不会执行，函数体只有在调用的时候才会执行，
2. 可以调用多次
</code></pre>
<p>代码示例：</p>
<pre><code class="lang-javascript">//声明函数
function sayHi(){
  console.log(&quot;吃了没？&quot;);
}
//调用函数
sayHi();
</code></pre>
<p>思考：</p>
<pre><code class="lang-javascript">1. 封装一个打招呼的函数
2. 封装一个函数，计算两个数的和
3. 封装一个函数，计算1-100之间所有数的和
</code></pre>
<h2 id="-">函数的参数</h2>
<blockquote>
<ol>
<li>形参（形式参数）：在函数声明时，设置的参数。作用是占位置。</li>
<li>实参（实际参数）：在函数调用时，传入的参数。作用：函数调用时，会把实参的值赋值给形参，这样形参就有了值。</li>
</ol>
</blockquote>
<p>语法：</p>
<pre><code class="lang-javascript">//带参数的函数声明
function 函数名(形参1, 形参2, 形参...){
  //函数体
}

//带参数的函数调用
函数名(实参1, 实参2, 实参3);
</code></pre>
<p>思考：</p>
<pre><code class="lang-javascript">1. 计算1-n之间所有数的和
2. 计算两个数的和
3. 计算m-n之间所有数的积
</code></pre>
<p>注意：</p>
<ul>
<li>形参在声明时，值不固定，只有在调用的时候，形参的值才确定，形参的值会跟着函数调用时的实参不一样而不一样。</li>
<li>如何确定形参：在声明函数的时候，碰到不确定的值的时候，就可以定义成形参。</li>
</ul>
<h2 id="-">函数的返回值</h2>
<blockquote>
<p>当函数执行完的时候，我们期望函数给我一些反馈（比如计算的结果），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值</p>
</blockquote>
<p>返回值语法：</p>
<pre><code class="lang-javascript">//声明一个带返回值的函数
function 函数名(形参1, 形参2, 形参...){
  //函数体
  return 返回值;
}

//可以通过变量来接收这个返回值
var 变量 = 函数名(实参1, 实参2, 实参3);
</code></pre>
<p>函数返回值注意事项：</p>
<ul>
<li>return后面的语句不执行。</li>
<li>函数可以没有返回值，函数如果没有return，那么返回结果是undefined。</li>
<li>函数的参数可以有多个，但是返回值只能有1个。</li>
</ul>
<p>思考：</p>
<pre><code class="lang-javascript">1. 求两个数的最大值
2. 求三个数的最大值
3. 求一个数组的最大值和最小值，并且返回。
</code></pre>
<h2 id="-">函数三要素</h2>
<p>函数三要素包括：函数名、参数、返回值</p>
<p>关于文档注释，javascript中还有一种注释叫做文档注释，经常用在函数声明处，用来解释这个函数的作用。</p>
<p>文档注释： <code>/**   这是文档注释 */</code></p>
<pre><code class="lang-javascript">/**
 * 求圆的面积
 * @param r {number} 圆的半径
 * @returns {number} 圆的周长
 */
function getArea (r) {
    return Math.PI * r * r;
}
</code></pre>
<p>思考1：</p>
<pre><code class="lang-javascript">1. 求任意半径的圆的面积
2. 求任意半径的圆的周长
3. 求任意2个数中的最大值
4. 求任意三个数中的最大值
</code></pre>
<p>思考2：</p>
<pre><code class="lang-javascript">1. 求任意数组中的最大值
2. 求任意数组中的最小值
3. 翻转任意数组，返回一个新的数组
4. 对任意数组从小到大排序
</code></pre>
<h2 id="-">函数的断点调试</h2>
<p>断点调试：</p>
<pre><code class="lang-javascript">1.    F8：跳到下一个断点，如果后面没有断点了，那么代码直接执行完。
2.    F10：单步调试（跳过函数调用）
3.    F11：单步调试（进入函数调用）
4.    shift+F11：跳出函数调用
</code></pre>
<h2 id="-">函数内部可以调用函数</h2>
<blockquote>
<p>在函数内部是可以继续调用别的函数的。</p>
</blockquote>
<pre><code class="lang-javascript">function fn1() {
    console.log(&quot;fn1开始...&quot;);
    fn2();
    console.log(&quot;fn1结束...&quot;);
}

function fn2 () {
    console.log(&quot;执行fn2的代码&quot;); 
    console.log(&quot;执行fn2的代码&quot;);
    console.log(&quot;执行fn2的代码&quot;);
}
//在函数1中调用了函数2
fn1();
</code></pre>
<p>思考：</p>
<pre><code class="lang-javascript">1. 封装一个函数，求阶乘
2. 封装一个函数，求阶乘和  1!+2!+3!+4!+5!
</code></pre>
<h2 id="-">递归函数（了解）</h2>
<blockquote>
<p>递归函数：自己直接或者间接调用自己的函数，递归函数一定要留有出口，不然就是死循环了</p>
</blockquote>
<p> 递归函数比较抽象，尤其是第一次接触的同学们，大家了解即可。</p>
<pre><code class="lang-javascript"> 1. 求1-100所有数的和
 2. 斐波那契数列，有个人想知道，一年之内一对兔子能繁殖多少对？于是就筑了一道围墙把一对兔子关在里面。已知一对兔子每个月可以生一对小兔子，而一对兔子从出生后第3个月起每月生一对小兔子。假如一年内没有发生死亡现象，那么，一对兔子一年内（12个月）能繁殖成多少对？
  //兔子的规律为数列，1，1，2，3，5，8，13，21 ,34 , 55, 89, 144
</code></pre>
<h2 id="-">函数也是一种类型</h2>
<h3 id="-">声明函数的两种方式</h3>
<p>函数声明：</p>
<pre><code class="lang-javascript">function 函数名(){
  //函数体
}
</code></pre>
<p>函数表达式(匿名函数)：</p>
<pre><code class="lang-javascript">var 函数名 = function(){
  //函数体
}
</code></pre>
<h3 id="-">函数可以作为参数</h3>
<blockquote>
<p>通常，我们把作为参数传递的函数叫做回调函数</p>
</blockquote>
<pre><code class="lang-javascript">function fn1(fn) {
  fn();
}
fn1(function(){
   console.log(&quot;哈哈&quot;); 
});
</code></pre>
<h3 id="-">函数可以作为返回值</h3>
<blockquote>
<p>在js高级中，闭包会使用到。</p>
</blockquote>
<pre><code class="lang-javascript">function fn1() {
    return function(){
      console.log(&quot;呵呵&quot;);
    }
}
fn1()();//调用
</code></pre>
<h2 id="-">匿名函数与自执行函数</h2>
<h3 id="-">自执行函数</h3>
<p>函数可以自执行</p>
<pre><code class="lang-javascript">(function fn(){
  console.log(&quot;我可以自己执行哦&quot;);
})();
</code></pre>
<h3 id="-">匿名函数</h3>
<blockquote>
<p>匿名函数：没有名字的函数</p>
</blockquote>
<p>匿名函数如何使用：</p>
<pre><code>1. 将匿名函数赋值给一个变量，这样就可以通过变量进行调用
2. 自执行（匿名函数自执行）
</code></pre><p>匿名函数自执行的作用：防止全局变量污染。</p>
<h2 id="-">作用域</h2>
<blockquote>
<p>作用域：变量起作用的区域</p>
</blockquote>
<p><strong>全局作用域</strong> ：在script标签内，函数外的变量就是全局作用域，在全局作用内声明的变量叫做<strong>全局变量</strong> 。全局变量可以在任意地方访问。</p>
<p><strong>函数作用域</strong> ：在函数内声明的变量叫做函数作用域，在函数作用域内声明的变量叫做<strong>局部变量</strong> ，局部变量只有在当前函数内才能访问到。</p>
<p><strong>块级作用域</strong>:一对花括号之间被称为一个代码块，在js中，没有块级作用域。</p>
<p>全局变量：在最函数外，script标签内声明的变量就是全局变量，全局变量在任何地方都能访问的到。</p>
<p>局部变量：在函数中声明的变量，就是局部变量，局部变量只有在当前函数体内能够访问。</p>
<p>隐式全局变量：没有使用var定义的变量也是全局变量，叫做隐式全局变量。</p>
<pre><code class="lang-javascript">var num = 11;//全局变量
function fn() {
  var num1 = 22;//局部变量
  num2 = 33;//隐式全局变量
  num = 33;//全局变量
  console.log(num1);
}
fn();
</code></pre>
<p>变量的查找规则：</p>
<ul>
<li>有局部变量就用局部变量，没有局部变量就用全局变量。</li>
</ul>
<pre><code class="lang-javascript">var num = 11;
function fn() {
  var num = 22;
  console.log(num);//22
}
fn();
console.log(num);//11
</code></pre>
<h2 id="-">预解析</h2>
<p>js执行代码分为两个过程：</p>
<ul>
<li>预解析过程（变量与函数提升）</li>
<li>代码一行一行执行</li>
</ul>
<p>预解析过程：</p>
<ol>
<li>预解析会把所有的var声明提升到当前作用域最前面，不会提升赋值</li>
<li>预解析会把所有的function声明提升到当前作用域最前面，不会提升调用，如果多个函数同名，后面的函数会覆盖前面的函数。</li>
<li>如果遇到同名的函数和变量，函数优先。</li>
</ol>
<p>思考：</p>
<pre><code class="lang-javascript">//1. 
console.log(num);
var num = 11;
console.log(num);
//2. getCool
//3
var a;
function a() {
  console.log(&quot;哈哈&quot;);
}

console.log(a);
</code></pre>
<p>面试题：</p>
<pre><code class="lang-javascript">//1. 
var num = 10;
fn1();
function fn1() {
  console.log(num);
  var num = 20;
}

//2. 
var a = 18;
fn2();
function fn2() {
    var b = 9;
    console.log(a);
    console.log(b);
}

//3.
fn3();
console.log(c);
console.log(b);
console.log(a);
function fn3() {
  var a = b = c = 9;
  console.log(a);
  console.log(b);
  console.log(c);
}
</code></pre>
</article>
  </div>
</body>
</html>
<script type="text/javascript" src="lib/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="lib/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="lib/js/ztree_toc.min.js"></script>
<script type="text/javascript" src="lib/js/toc_conf.js"></script>
<script src="lib/js/highlight.min.js"></script>
<script>
  $(document).ready(function () {
    // 代码高亮的js代码
    hljs.initHighlightingOnLoad();

    //生成侧边栏的代码
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)

    var conf = eval(jquery_ztree_toc_opts);
    $('#tree').ztree_toc(conf);
  });
</script>